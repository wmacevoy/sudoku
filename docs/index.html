<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Intentional Sudoku</title>
  <style>
    :root{
      --bg:#0b0c10;
      --panel:#0f141d;
      --ink:#e8ecf2;
      --muted:#91a0b6;
      --accent:#60a5fa;
      --accent-2:#22d3ee;
      --danger:#f87171;
      --grid:#1f2430;
      --strong:#e2e8f0;
      --cell:#0e1726;
      --cell-alt:#101a2d;
      --hit:#0ea5e9;
      --maybe:#334155;
    }
    *{box-sizing:border-box;}
    body{margin:0; font-family: "Inter", ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; background:var(--bg); color:var(--ink); display:flex; flex-direction:column; min-height:100vh;}
    .topbar{display:flex; align-items:center; justify-content:space-between; padding:14px 16px; background:var(--panel); gap:12px; position:sticky; top:0; z-index:10; border-bottom:1px solid #111827;}
    .brand{font-weight:700; letter-spacing:0.3px;}
    .controls{display:flex; align-items:center; gap:10px; flex-wrap:wrap;}
    .help-toggle{display:flex; align-items:center; gap:6px; font-size:13px; color:var(--muted);}
    .help-toggle input{accent-color:var(--accent);}
    select, button{background:var(--cell); border:1px solid var(--grid); color:var(--ink); border-radius:10px; padding:9px 12px; font-size:14px;}
    button{cursor:pointer;}
    button.toggle{min-width:42px; font-weight:700;}
    button.toggle.active{background:var(--accent-2); color:#0b0c10; border-color:var(--accent-2);}
    button:focus-visible, select:focus-visible{outline:2px solid var(--accent);}
    button.primary{background:var(--accent); color:#0b0c10; border-color:var(--accent);}
    main.layout{flex:1; display:flex; flex-direction:column; gap:12px; padding:14px; max-width:1100px; width:100%; margin:0 auto;}
    .board-section{display:flex; justify-content:center;}
    .grid{width:min(100%, 760px); aspect-ratio:1/1; background:var(--panel); border-radius:18px; padding:12px; display:grid; grid-template-columns:repeat(9,1fr); grid-template-rows:repeat(9,1fr); gap:1px; box-shadow:0 10px 24px rgba(0,0,0,0.35), inset 0 0 0 2px var(--strong);}
    .cell{position:relative; background:var(--cell); display:flex; align-items:center; justify-content:center; font-weight:700; font-size:clamp(16px, 3vw, 32px); transition:background 0.12s, box-shadow 0.12s; border:1px solid var(--grid);}
    .cell:nth-child(odd){background:var(--cell-alt);}
    .cell[data-row="1"], .cell[data-row="4"], .cell[data-row="7"]{border-top:1px solid var(--strong);}
    .cell[data-col="1"], .cell[data-col="4"], .cell[data-col="7"]{border-left:1px solid var(--strong);}
    .cell[data-col="9"]{border-right:1px solid var(--strong);}
    .cell[data-row="9"]{border-bottom:1px solid var(--strong);}
    .cell.selected{outline:2px dotted var(--accent); outline-offset:-4px; border-radius:10px;}
    .cell.highlight-hit{background:rgba(96,165,250,0.12); color:var(--strong);}
    .cell.highlight-maybe{background:rgba(51,65,85,0.65);}
    .cell.option-focus{box-shadow: inset 0 0 0 2px var(--accent);}
    .cell.option-dim{opacity:0.45; filter:saturate(0.45);}
    .cell.uncertain .value{color:var(--danger);}
    .cell.single-option .value{font-weight:800; color:var(--accent-2);}
    .value{z-index:1;}
    .options{position:absolute; inset:6px; display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(3,1fr); gap:2px; font-size:11px; color:var(--muted); pointer-events:none; z-index:0;}
    .options.cover{inset:0; background:var(--cell); border-radius:12px; box-shadow: inset 0 0 0 1px var(--grid);}
    .options.hidden{display:none;}
    .option{display:flex; align-items:center; justify-content:center; border-radius:4px; opacity:0.25;}
    .option.active{opacity:0.85;}
    .option.single{font-weight:700; color:var(--accent-2); opacity:1;}
    .option.placed{color:var(--strong); font-weight:700; opacity:1;}
    .option.highlight{color:var(--accent-2); background:rgba(34,211,238,0.12); opacity:1;}
    .notes{position:absolute; inset:6px; display:flex; flex-wrap:wrap; gap:3px; align-content:flex-start; font-size:12px; color:var(--muted);}
    .legend{margin:0; padding:12px 14px; background:var(--panel); border-radius:12px; color:var(--muted); line-height:1.4;}
    .keypad{position:sticky; bottom:0; background:rgba(11,12,16,0.9); backdrop-filter: blur(8px); display:grid; grid-template-columns:repeat(5, minmax(0,1fr)); gap:8px; padding:12px; border-top:1px solid #111827;}
    .keypad button{padding:14px 0; font-size:16px; border-radius:12px; border:1px solid var(--grid); background:var(--cell); color:var(--ink);}
    .keypad button.active{border-color:var(--accent); color:var(--accent);}
    .keypad button.highlighting{border-color:var(--accent-2); color:var(--accent-2);}
    @media (min-width: 768px){
      .grid{width:min(90vw, 620px);}
      .keypad{grid-template-columns:repeat(10, minmax(0,1fr));}
      .keypad button{padding:12px 0;}
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="brand">Intentional Sudoku</div>
    <div class="controls">
      <select id="sel-diff">
        <option value="simple">Simple</option>
        <option value="easy">Easy</option>
        <option value="medium" selected>Medium</option>
        <option value="hard">Hard</option>
      </select>
      <button id="btn-new">New</button>
      <button id="btn-solve">Solve!</button>
      <button id="btn-print">Print</button>
      <button id="btn-toggle-options" class="toggle" title="Toggle option grid" aria-label="Toggle option grid">#</button>
      <button id="btn-share" class="primary">Share Link</button>
      <label class="help-toggle" title="Toggle helper auto-candidates">
        <input type="checkbox" id="chk-help" checked />
        Help
      </label>
    </div>
  </header>
  <main class="layout">
    <section class="board-section">
      <div id="grid" class="grid" role="grid" aria-label="Sudoku grid"></div>
    </section>
    <p id="legend" class="legend">Select a digit, then double tap a cell to place it. Use ? then double tap to mark uncertainty. Tap # to toggle the per-cell option grid. Turn off Help to manage options manually.</p>
  </main>
  <div id="keypad" class="keypad" aria-label="Digit keypad"></div>

  <script type="module">
    import { SudokuEngine, DIGITS, N, make2D } from './sudoku-engine.js';
    import { SudokuRenderer } from './sudoku-render.js';

    const gridEl = document.getElementById('grid');
    const legendEl = document.getElementById('legend');
    const selDiff = document.getElementById('sel-diff');
    const btnNew = document.getElementById('btn-new');
    const btnSolve = document.getElementById('btn-solve');
    const btnPrint = document.getElementById('btn-print');
    const btnToggleOptions = document.getElementById('btn-toggle-options');
    const btnShare = document.getElementById('btn-share');
    const chkHelp = document.getElementById('chk-help');
    const keypadEl = document.getElementById('keypad');

    const game = new SudokuEngine();
    const notes = make2D(N, N, () => new Set());
    const noteOffs = make2D(N, N, () => new Set());
    let selected = { r: 0, c: 0 };
    let activeDigit = null; // number or '?' or null
    let highlightDigit = null;
    let showOptionGrid = false;
    let helpEnabled = true;

    const renderer = new SudokuRenderer({ container: gridEl });

    // --- Tap helpers (single vs double) ---
    function addTapTarget(el, onSingle, onDouble) {
      const threshold = 275;
      let last = 0;
      el.addEventListener('pointerdown', (e) => {
        const now = Date.now();
        if (now - last < threshold) {
          last = 0;
          if (onDouble) onDouble(e);
        } else {
          last = now;
          setTimeout(() => {
            if (last && Date.now() - last >= threshold) {
              last = 0;
              if (onSingle) onSingle(e);
            }
          }, threshold + 10);
        }
      });
    }

    // --- State helpers ---
    function clearNotes() {
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          notes[r][c].clear();
          noteOffs[r][c].clear();
        }
      }
    }

    function serializeNotes() {
      return notes.map((row) => row.map((set) => [...set].sort((a, b) => a - b)));
    }

    function serializeNoteOffs() {
      return noteOffs.map((row) => row.map((set) => [...set].sort((a, b) => a - b)));
    }

    function restoreNotes(data) {
      clearNotes();
      if (!Array.isArray(data)) return;
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          const arr = data[r]?.[c];
          if (Array.isArray(arr)) {
            arr.forEach((d) => {
              if (DIGITS.includes(d)) notes[r][c].add(d);
            });
          }
        }
      }
    }

    function restoreNoteOffs(data) {
      if (!Array.isArray(data)) return;
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          const arr = data[r]?.[c];
          noteOffs[r][c].clear();
          if (Array.isArray(arr)) {
            arr.forEach((d) => {
              if (DIGITS.includes(d)) noteOffs[r][c].add(d);
            });
          }
        }
      }
    }

    function setLegend(msg) {
      if (legendEl) legendEl.textContent = msg;
    }

    function setActiveDigit(d) {
      activeDigit = d;
      if (!helpEnabled) highlightDigit = null;
      updateKeypadUI();
      render();
    }

    function toggleHighlightDigit(d) {
      highlightDigit = highlightDigit === d ? null : d;
      render();
      if (highlightDigit) {
        setLegend(
          helpEnabled
            ? `Highlighting ${highlightDigit}: filled cells and valid candidates are shaded.`
            : `Highlighting ${highlightDigit}: filled cells are shaded. Turn on Help to auto-highlight candidates.`
        );
      } else {
        setLegend('Highlight cleared.');
      }
    }

    function selectCell(r, c) {
      selected = { r, c };
      render();
    }

    function makeCertain(r, c, val) {
      if (game.board[r][c] === val) {
        game.place(r, c, 0, true);
        game.markUncertain(r, c, false);
      } else {
        game.markUncertain(r, c, false);
        game.place(r, c, val, true);
      }
      notes[r][c].clear();
      noteOffs[r][c].clear();
      render();
      saveState();
    }

    function makeUncertain(r, c) {
      game.place(r, c, 0, true);
      game.markUncertain(r, c, true);
      notes[r][c].clear();
      noteOffs[r][c].clear();
      render();
      saveState();
    }

    function toggleNote(r, c, d) {
      if (game.board[r][c] !== 0) return;
      const on = notes[r][c];
      const off = noteOffs[r][c];
      if (on.has(d)) {
        on.delete(d);
        off.add(d);
      } else if (off.has(d)) {
        off.delete(d);
      } else {
        on.add(d);
      }
      render();
      saveState();
    }

    function moveSelection(dr, dc) {
      const nr = Math.max(0, Math.min(N - 1, selected.r + dr));
      const nc = Math.max(0, Math.min(N - 1, selected.c + dc));
      if (nr === selected.r && nc === selected.c) return;
      selected = { r: nr, c: nc };
      render();
    }

    function isUniqueInRow(r, c, d) {
      for (let cc = 0; cc < N; cc++) {
        if (cc === c) continue;
        if (game.board[r][cc] !== 0) continue;
        if (game.candidates[r][cc].has(d)) return false;
      }
      return true;
    }

    function isUniqueInCol(r, c, d) {
      for (let rr = 0; rr < N; rr++) {
        if (rr === r) continue;
        if (game.board[rr][c] !== 0) continue;
        if (game.candidates[rr][c].has(d)) return false;
      }
      return true;
    }

    function isUniqueInBox(r, c, d) {
      const R = Math.floor(r / 3) * 3;
      const C = Math.floor(c / 3) * 3;
      for (let dr = 0; dr < 3; dr++) {
        for (let dc = 0; dc < 3; dc++) {
          const rr = R + dr;
          const cc = C + dc;
          if (rr === r && cc === c) continue;
          if (game.board[rr][cc] !== 0) continue;
          if (game.candidates[rr][cc].has(d)) return false;
        }
      }
      return true;
    }

    function autoFillOptions(r, c) {
      if (game.board[r][c] !== 0) return;
      const candSet = game.candidates[r][c];
      const blocked = noteOffs[r][c];
      const baseCands = (candSet.size ? [...candSet] : [...DIGITS]).filter((d) => !blocked.has(d));
      const uniques = [];
      for (const d of baseCands) {
        if (isUniqueInRow(r, c, d) || isUniqueInCol(r, c, d) || isUniqueInBox(r, c, d)) {
          uniques.push(d);
        }
      }
      const target = uniques.length ? uniques : baseCands;
      notes[r][c].clear();
      target.forEach((d) => notes[r][c].add(d));
      render();
      saveState();
      setLegend(
        uniques.length
          ? `Auto-filled r${r + 1}c${c + 1} with unique candidate${uniques.length > 1 ? 's' : ''}: ${uniques.join(' ')}.`
          : `Auto-filled r${r + 1}c${c + 1} with basic candidates: ${target.join(' ')}.`
      );
    }

    function refreshAutoOptions({ reset = false } = {}) {
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          if (game.board[r][c] !== 0) continue;
          const candSet = game.candidates[r][c];
          const base = candSet.size ? candSet : new Set(DIGITS);
          const off = noteOffs[r][c];
          const note = notes[r][c];
          if (reset) {
            off.clear();
            note.clear();
            base.forEach((d) => note.add(d));
          } else if (helpEnabled) {
            for (const d of [...note]) {
              if (!base.has(d) || off.has(d)) note.delete(d);
            }
          }
        }
      }
    }

    function updateOptionToggleUI() {
      btnToggleOptions.classList.toggle('active', showOptionGrid);
      btnToggleOptions.setAttribute('aria-pressed', showOptionGrid ? 'true' : 'false');
      chkHelp.checked = helpEnabled;
    }

    function handleKeydown(e) {
      const tag = (e.target && e.target.tagName) || '';
      if (/^(input|textarea|select|button)$/i.test(tag)) return;

      switch (e.key) {
        case 'ArrowUp':
          moveSelection(-1, 0);
          e.preventDefault();
          return;
        case 'ArrowDown':
          moveSelection(1, 0);
          e.preventDefault();
          return;
        case 'ArrowLeft':
          moveSelection(0, -1);
          e.preventDefault();
          return;
        case 'ArrowRight':
          moveSelection(0, 1);
          e.preventDefault();
          return;
        default:
          break;
      }

      const shiftDigitMap = { '!': 1, '@': 2, '#': 3, '$': 4, '%': 5, '^': 6, '&': 7, '*': 8, '(': 9 };
      let digit = null;
      let isQuestion = false;
      let isDouble = false;

      if (e.key === '?' || e.key === '/') {
        isQuestion = true;
        isDouble = e.shiftKey;
      } else if (/^[1-9]$/.test(e.key)) {
        digit = Number(e.key);
        isDouble = e.shiftKey;
      } else if (shiftDigitMap[e.key]) {
        digit = shiftDigitMap[e.key];
        isDouble = true;
      }

      if (isQuestion) {
        setActiveDigit('?');
        if (isDouble) handleCellDoubleTap(selected.r, selected.c);
        else handleCellSingleTap(selected.r, selected.c);
        e.preventDefault();
        return;
      }
      if (digit) {
        setActiveDigit(digit);
        if (isDouble) handleCellDoubleTap(selected.r, selected.c);
        else handleCellSingleTap(selected.r, selected.c);
        e.preventDefault();
      }
    }

    // --- Rendering ---
    function render() {
      renderer.setShowOptionGrid(showOptionGrid);
      renderer.render({
        board: game.board,
        uncertain: game.uncertain,
        notes,
        noteOffs,
        candidates: game.candidates,
        selected,
        highlightDigit: helpEnabled ? highlightDigit : null,
        activeDigit,
        helpEnabled,
        showOptionGrid,
        addTapTarget,
        onCellSingleTap: handleCellSingleTap,
        onCellDoubleTap: handleCellDoubleTap
      });
      updateKeypadUI();
      updateOptionToggleUI();
    }

    function updateKeypadUI() {
      keypadEl.querySelectorAll('button').forEach((btn) => {
        const digit = btn.dataset.digit;
        btn.classList.toggle(
          'active',
          (digit === '?' && activeDigit === '?') ||
            (digit !== '?' && Number(digit) === activeDigit)
        );
        btn.classList.toggle(
          'highlighting',
          digit !== '?' && Number(digit) === highlightDigit
        );
      });
    }

    // --- Interaction handlers ---
    function handleCellSingleTap(r, c) {
      selectCell(r, c);
      const val = game.board[r][c];
      if (activeDigit === '?') {
        if (val !== 0) {
          if (!showOptionGrid) {
            makeUncertain(r, c);
            setLegend(`Marked r${r + 1}c${c + 1} as uncertain.`);
          } else {
            setLegend('Double tap to mark this cell uncertain.');
          }
          return;
        }
        autoFillOptions(r, c);
        return;
      }
      const forceDouble = !showOptionGrid && typeof activeDigit === 'number';
      if (forceDouble) {
        handleCellDoubleTap(r, c);
        return;
      }
      if (val === 0 && typeof activeDigit === 'number') {
        toggleNote(r, c, activeDigit);
        setLegend(`Toggled option ${activeDigit} at r${r + 1}c${c + 1}.`);
      }
    }

    function handleCellDoubleTap(r, c) {
      if (activeDigit === '?') {
        if (game.board[r][c] !== 0) {
          makeUncertain(r, c);
          setLegend(`Marked r${r + 1}c${c + 1} as uncertain.`);
        } else {
          autoFillOptions(r, c);
        }
        return;
      }
      if (typeof activeDigit === 'number') {
        makeCertain(r, c, activeDigit);
        setLegend(`Placed ${activeDigit} at r${r + 1}c${c + 1}. (Double tap with same digit to clear.)`);
      }
    }

    function toggleOptionGrid() {
      showOptionGrid = !showOptionGrid;
      render();
      saveState();
      setLegend(
        showOptionGrid
          ? 'Showing option grid in each cell. Tap digits to update as usual.'
          : 'Option grid hidden.'
      );
    }

    function toggleHelp() {
      helpEnabled = chkHelp.checked;
      if (helpEnabled) {
        refreshAutoOptions({ reset: true });
      }
      highlightDigit = null;
      render();
      saveState();
      setLegend(helpEnabled ? 'Help on: candidates auto-highlight and eliminate.' : 'Help off: manage options manually.');
    }

    function openPrintView() {
      const win = window.open('', '_blank', 'width=900,height=1100');
      if (!win) {
        setLegend('Pop-up blocked. Please allow pop-ups to print.');
        return;
      }
      const board = game.board;
      const includeOptions = showOptionGrid;
      const html = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8" />
          <title>Sudoku Print</title>
          <style>
            *{box-sizing:border-box;}
            body{margin:20px; font-family: "Inter", ui-sans-serif, system-ui; color:#000;}
            h1{margin:0 0 12px 0; font-size:20px;}
            .p-grid{display:grid; grid-template-columns:repeat(9,1fr); grid-template-rows:repeat(9,1fr); width:95vw; max-width:780px; aspect-ratio:1/1; border:2px solid #000;}
            .p-cell{border:1px solid #000; position:relative; display:flex; align-items:center; justify-content:center; font-size:26px; font-weight:700; min-height:40px;}
            .p-cell[data-row="1"], .p-cell[data-row="4"], .p-cell[data-row="7"]{border-top:2px solid #000;}
            .p-cell[data-col="1"], .p-cell[data-col="4"], .p-cell[data-col="7"]{border-left:2px solid #000;}
            .p-cell[data-col="9"]{border-right:2px solid #000;}
            .p-cell[data-row="9"]{border-bottom:2px solid #000;}
            .p-cands{position:absolute; inset:4px; display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(3,1fr); font-size:11px; color:#666; line-height:1.1;}
            .p-cand{display:flex; align-items:center; justify-content:center;}
            @media print{
              body{margin:0.5in;}
            }
          </style>
        </head>
        <body>
          <h1>Sudoku</h1>
          <div class="p-grid">
            ${board
              .map((row, r) =>
                row
                  .map((val, c) => {
                    const notesArr = includeOptions ? [...notes[r][c]].sort((a, b) => a - b) : [];
                    const candHTML =
                      includeOptions && notesArr.length && val === 0
                        ? `<div class="p-cands">${DIGITS.map(
                            (d) =>
                              `<div class="p-cand">${notesArr.includes(d) ? d : ''}</div>`
                          ).join('')}</div>`
                        : '';
                    return `<div class="p-cell" data-row="${r + 1}" data-col="${c + 1}">${
                      val || ''
                    }${candHTML}</div>`;
                  })
                  .join('')
              )
              .join('')}
          </div>
        </body>
        </html>
      `;
      win.document.write(html);
      win.document.close();
      win.focus();
      setTimeout(() => {
        try {
          win.print();
        } catch (_) {}
      }, 50);
    }

    function solvePuzzle() {
      const { status, solution } = game.solve(game.board);
      if (status === 'unique' && solution) {
        game.loadBoard(solution);
        clearNotes();
        highlightDigit = null;
        selected = { r: 0, c: 0 };
        render();
        saveState();
        setLegend('Solved! Unique solution applied to the board.');
      } else if (status === 'impossible') {
        setLegend('No solution exists for this grid.');
      } else if (status === 'multiple') {
        setLegend('More than one solution exists; puzzle is ambiguous.');
      } else {
        setLegend('Solve check failed.');
      }
    }

    // --- Keypad setup ---
    function buildKeypad() {
      keypadEl.innerHTML = '';
      const keys = ['?', ...DIGITS];
      keys.forEach((d) => {
        const btn = document.createElement('button');
        btn.dataset.digit = String(d);
        btn.textContent = d;
        addTapTarget(
          btn,
          () => {
            setActiveDigit(d === '?' ? '?' : Number(d));
            setLegend(`Active digit: ${d === '?' ? '?' : d}. Double tap a cell to apply.`);
          },
          () => {
            setActiveDigit(d === '?' ? '?' : Number(d));
            setLegend(`Active digit: ${d === '?' ? '?' : d}. Double tap a cell to apply.`);
          }
        );
        keypadEl.appendChild(btn);
      });
    }

    // --- Sharing helpers ---
    function base64Encode(str) {
      return btoa(String.fromCharCode(...new TextEncoder().encode(str)));
    }
    function base64Decode(b64) {
      return new TextDecoder().decode(Uint8Array.from(atob(b64), (c) => c.charCodeAt(0)));
    }

    function currentState() {
      return game.currentState({
        diff: selDiff.value,
        notes: serializeNotes(),
        notesOff: serializeNoteOffs(),
        active: activeDigit === '?' ? '?' : activeDigit,
        highlight: highlightDigit,
        optionGrid: showOptionGrid,
        help: helpEnabled
      });
    }

    function applyShareState(state) {
      if (!state || !state.initial) return false;
      if (state.rngSeed) game.setRNGSeed(state.rngSeed);
      if (!game.applyState(state)) return false;
      selDiff.value = state.diff || 'medium';
      activeDigit =
        state.active === '?'
          ? '?'
          : Number.isInteger(state.active)
          ? state.active
          : null;
      helpEnabled = state.help !== false;
      highlightDigit = Number.isInteger(state.highlight) ? state.highlight : null;
      showOptionGrid = !!state.optionGrid;
      restoreNotes(state.notes);
      restoreNoteOffs(state.notesOff);
      render();
      return true;
    }

    function createShareLink() {
      const payload = currentState();
      const b64 = base64Encode(JSON.stringify(payload));
      const url = new URL(window.location.href);
      url.hash = 's=' + b64;
      return url.toString();
    }

    async function copyShareLink() {
      const link = createShareLink();
      if (navigator.share) {
        try {
          await navigator.share({ url: link, title: 'Intentional Sudoku' });
          setLegend('Share link opened.');
          return;
        } catch (_) {
          // fall through to clipboard
        }
      }
      if (navigator.clipboard?.writeText) {
        try {
          await navigator.clipboard.writeText(link);
          setLegend('Share link copied to clipboard.');
          return;
        } catch (_) {
          // fall back to prompt
        }
      }
      prompt('Copy your share link:', link);
    }

    function saveState() {
      try {
        localStorage.setItem('sudoku_state_v2', JSON.stringify(currentState()));
      } catch (_) {}
    }

    function restoreFromLocal() {
      try {
        const raw = localStorage.getItem('sudoku_state_v2');
        if (!raw) return false;
        const st = JSON.parse(raw);
        if (!st || !st.initial) return false;
        return applyShareState(st);
      } catch (_) {
        return false;
      }
    }

    function restoreFromURL() {
      const h = location.hash;
      if (!h || !h.startsWith('#s=')) return false;
      try {
        const b64 = h.slice(3);
        const json = base64Decode(b64);
        const st = JSON.parse(json);
        if (!st || !st.initial) return false;
        return applyShareState(st);
      } catch (_) {
        return false;
      }
    }

    // --- Puzzle setup ---
    function newPuzzle(diff) {
      const next = game.createPuzzle(diff);
      game.loadBoard(next);
      clearNotes();
      highlightDigit = null;
      selected = { r: 0, c: 0 };
      if (helpEnabled) {
        refreshAutoOptions({ reset: true });
      }
      render();
      saveState();
      setLegend(`New ${diff} puzzle loaded.`);
    }

    // --- Bootstrap ---
    function init() {
      buildKeypad();
      btnNew.addEventListener('click', () => newPuzzle(selDiff.value));
      btnSolve.addEventListener('click', solvePuzzle);
      btnPrint.addEventListener('click', openPrintView);
      btnToggleOptions.addEventListener('click', toggleOptionGrid);
      btnShare.addEventListener('click', copyShareLink);
      chkHelp.addEventListener('change', toggleHelp);
      document.addEventListener('keydown', handleKeydown);
      selDiff.addEventListener('change', () => {
        saveState();
        setLegend(`Difficulty set to ${selDiff.value}. Use "New" for a fresh puzzle.`);
      });

      if (!restoreFromURL()) {
        if (!restoreFromLocal()) {
          newPuzzle('medium');
        }
      }
      render();
    }

    init();
  </script>
</body>
</html>
